---
title: "Block-level UFP predictions - Slightly modified from the original Saha et al. 2021 Model"
author: "Magali Blanco"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
    number_sections: true
    toc_float: true
    collapsed: false
    smooth_scroll: false
editor_options: 
  chunk_output_type: console
---

# Notes

UFP predictions have been updated:       

* the new predictions use recreated (similar) 1k grid UFP data to fit the model   
* predictions are for all 2010 Census blocks (like the original model) as well as for 2020 Census blocks    
* we generate predictions for all blocks (not just those with pop>0 or those within the geocovariate modeling space) since cohort members may live at highly populated locations without predictions (e.g., Manhattan)      
* to address extreme UFP predictions due to modeling outside of the covariate space, we winsorize the predictions below/above the specific quantiles
  * there are many ways to do this (e.g., could have winsorize the covariates). This is probably the most straightforward. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, 
                      cache=F, cache.comments = F, 
                      message = F, warning = F, 
                      tidy.opts=list(width.cutoff=60), tidy=TRUE, 
                      fig.height = 8, fig.width = 10)  

# Clear workspace of all objects and unload all extra (non-base) packages
rm(list = ls(all = TRUE))
if (!is.null(sessionInfo()$otherPkgs)) {
  res <- suppressWarnings(
    lapply(paste('package:', names(sessionInfo()$otherPkgs), sep=""),
           detach, character.only=TRUE, unload=TRUE, force=TRUE))
}

pacman::p_load(tidyverse, sf,
               knitr, kableExtra,
               #ggrepel, # geom_text_repel()
               tigris)  

# ggplot settings
theme_set(theme_bw())
theme_update(legend.position = "bottom")

set.seed(1)
##################################################################################################
# speed thigns up
testing_mode <- FALSE #TRUE #e.g., reduce visit designs & windows/quantile combinations

##################################################################################################
# VARIABLES
##################################################################################################
## for state outlines (doesn't impact blocks?)
yr <- 2020
project_crs <- 4269 #lat/long CRS commonly used in US 


##################################################################################################
# LOAD DATA
##################################################################################################
# quantile summary files
ufp_quantiles_2010 <- readRDS(file.path("output", "winsorize", "raw_quantiles_ufp_covs_2010.rds")) %>%
  mutate(year=2010)

# ufp_quantiles_2020 <- readRDS(file.path("output", "winsorize", "raw_quantiles_ufp_covs_2020.rds")) %>%
#   mutate(year=2020) 

# winsorized predictions
ufp_2010 <- readRDS(file.path("output", "predictions", "original_model", "blocks", "modified", "ufp_covs_2010.rds")) %>%
  rename(ufp_original=ufp) %>%
  mutate(year=2010)

if(testing_mode==TRUE){
  ufp_2010 <- slice_sample(ufp_2010, n = 1e4
                            #n=1e6
                           )
  }

# ufp_2020 <- readRDS(file.path("output", "predictions", "original_model", "blocks", "modified", "ufp_covs_2020.rds"))  %>%
#   rename(ufp_original_ufp=ufp) %>%
#   mutate(year=2010)

# combine both years
ufp <- rbind(ufp_2010 #, ufp_2020
             ) %>%
  mutate(ufp_difference = ufp_winsorized-ufp_original,
         
         winsorized = ifelse(ufp_difference<0, "prediction reduced",
                                   ifelse(ufp_difference>0, "prediction increased", "not changed")
                                   )
         )

##################################################################################################
# census data
## 2013-2022 available
state_file <- file.path("output", "other", "states.rda")
if(file.exists(state_file)) {
  states <- readRDS(state_file)
  } else{
    states <- states(year = yr, cb = T #crude resolution is OK
             ) %>%
      filter(!NAME %in% c("Alaska", "Hawaii", "Puerto Rico", "Commonwealth of the Northern Mariana Islands", "Guam", "United States Virgin Islands", "District of Columbia", "American Samoa"))

    saveRDS(states, state_file)
  }

state_names <- unique(states$NAME)
if(testing_mode==TRUE){state_names <- c("New York", "Rhode Island")}

# state & county FIPS codes
data(fips_codes)

# urban areas
## include both "urbanized areas," which are densely developed areas with a population of at least 50,000, and "urban clusters," which have a population of greater than 2,500 but less than 50,000
urban_areas_file <- file.path("output", "other", "urban_areas.rda")
if(!file.exists(urban_areas_file)) {
  some_urban_areas <- urban_areas()
  saveRDS(some_urban_areas, urban_areas_file)
}

some_urban_areas <- readRDS(urban_areas_file) %>%
  filter(grepl("Urbanized Area", NAMELSAD10)) %>%
  mutate(NAME10 = gsub(", .*", "", NAME10)) %>%
  #?? some lare areas
  arrange(desc(ALAND10)) %>%
  slice(1:40)

#metro_areas <- metro_divisions()
# places_test <- places() # error
# test_statistical_area <- combined_statistical_areas()

##################################################################################################
# COMMON VARIABLES
##################################################################################################
years <- unique(ufp$year)

```

# Blocks with missing predictions

these blocks have missing predictions due to missing model covariates 

```{r}
# this_year=years[1]
lapply(years, function(this_year){
  ufp %>%
    filter(year==this_year) %>%
    mutate(missing_imp_a00750 = ifelse(is.na(imp_a00750), "missing imp_a00750", "UFP prediction available" )) %>%
    filter(missing_imp_a00750 == "missing imp_a00750") %>%
    st_as_sf(coords = c('long_block', 'lat_block'), crs=project_crs) %>%
    
    ggplot() + 
    geom_sf(data = states, fill=alpha(0.01)) +
    geom_sf_text(data = states, aes(label=STUSPS)) +
    geom_sf(aes(col=missing_imp_a00750), alpha=1) + 
    labs(title = "Blocks with missing covariates (i.e., predictions)",
         subtitle = this_year)
  
  ggsave(file.path("output", "summary", paste0("missing_predictions_", this_year, ".png")), width = 16, height = 10)

})

```


# Quantiles used to winsorize predictions   

quantiles are based on available predictions (blocks without missing covariates) from the original UFP model predictions

We are currently winsorizing at the 1st and 99th percentiles 

```{r}
bind_rows(ufp_quantiles_2010#, 
          #ufp_quantiles_2020
          ) %>%
  filter(quantile %in% c(0.02,0.98,
                         0.01, 0.99
                         )) %>%
  select(year, everything()) %>%
  mutate(conc = round(conc),
         year = as.character(year)) %>%
  kable(caption = "Quantiles used to winsorize year-specific predictions",
        format.args = list(big.mark=",")) %>%
  kable_styling()


```

# Distribution of UFP Predictions before & after winsorization

```{r}
ufp %>%
  select(block_key, block_year=year, contains("ufp")) %>%
  pivot_longer(cols = contains("ufp")) %>%
  mutate(block_year = as.character(block_year)) %>%
  group_by(block_year, name) %>%
  summarize(
    n = n(),
    missing = sum(is.na(value)),
    min=min(value, na.rm = T),
    Q01 = quantile(value, probs = 0.01, na.rm = T),
    Q05 = quantile(value, probs = 0.05, na.rm = T),
    Q25 = quantile(value, probs = 0.05, na.rm = T),
    Q50 = quantile(value, probs = 0.50, na.rm = T),
    Q75 = quantile(value, probs = 0.75, na.rm = T),
    Q95 = quantile(value, probs = 0.95, na.rm = T),
    Q99 = quantile(value, probs = 0.99, na.rm = T),
    max = max(value, na.rm = T)
  ) %>%
  kable(caption = "Predicted block-level PNC (pt/cm3)", 
        digits = 0, format.args = list(big.mark=",")) %>%
  kable_styling() 

```


# Comparison of original & winsorized UFP predictions 

winsorizing mostly impacts extremely high UFP predictions

```{r}
ufp %>%
  select(block_key, year, contains("ufp")) %>%
  pivot_longer(cols=contains("ufp")) %>%
  
  ggplot(aes(x=value, fill=name)) + 
  geom_histogram(position = "dodge") + 
  facet_wrap(~year) +
  labs(title = "Distribution of original and winsorized UFP predictions")

# scatterplot
ufp %>%
  ggplot(aes(x=ufp_original, y=ufp_winsorized, col=winsorized)) +
  facet_wrap(~year) +
  geom_abline(slope = 1, intercept = 0, linetype=2, alpha=0.5) +
  geom_point(alpha=0.1) + 
  labs(title = "Comparison of UFP predictions before and after winsorizing ")

```

# Prediction Maps

maps of original (pre-winsorization) UFP predictions, winsorized predictions, and prediction differences

* blocks with winsorized predictions are distributed throughout the US       
* locations where no predictions were originally generated by the original Saha model (e.g., Manhattan) are not necessarily the primary places that now have winsorized predictions. Saha et al. excluded blocks with extreme covariate values. We have winsorized the final predictions if they are extreme.          

```{r}

ufp_prediction_types <- grep("ufp", names(ufp), value = T)

# ufp_type = ufp_prediction_types[3]
lapply(ufp_prediction_types, function(ufp_type){
  
  temp <- ufp  
  
  if(ufp_type=="ufp_difference"){
    temp <- filter(ufp, winsorized != "not changed")
    }
  
  
  p <- temp %>%
    filter(year==2010) %>%
    pivot_longer(cols = contains("ufp")) %>% 
    filter(name==ufp_type) %>%  
    # 1,000s of pt/cm3
    mutate(value = value/1e3) %>%
    st_as_sf(coords = c('long_block', 'lat_block'), crs=project_crs) %>%
    
    ggplot() + 
    geom_sf(data = states, fill=alpha(0.01)) +
    # geom_sf_text(data = some_urban_areas, aes(label=NAME10), 
    #              #position = position_jitter(),
    #              #check_overlap = T, nudge_x = 1,
    #              ) +
    #geom_text_sf_repel(data = some_urban_areas, aes(label=NAME10)) +
     
    geom_sf(aes(col=value), #alpha=0.1, 
            size=0.05) + 
    facet_wrap(~name) +
    scale_color_viridis_c(trans="log10") + #scale_color_gradient2(midpoint = 30)
    labs(col="PNC (10^3 pt/cm3)")
  
  # if(ufp_type=="ufp_difference"){
  #   p <- p + scale_color_gradient2(low = "red", high = "blue")
  # }

  p
  
  ggsave(file.path("output", "summary", paste0("predictions_", ufp_type, ".png")), width = 16, height = 10)
  
  })

```


```{r}
# this_year=years[1]
lapply(years, function(this_year){
  ufp %>%
    filter(year==this_year,
           #winsorized==TRUE
           winsorized != "not changed"
           ) %>%
    st_as_sf(coords = c('long_block', 'lat_block'), crs=project_crs) %>%
  
    ggplot() + 
    geom_sf(data = states, fill=alpha(0.01)) +
    geom_sf_text(data = states, aes(label=STUSPS)) +
    geom_sf_text(data = some_urban_areas, aes(label=NAME10), size=3, col="purple",
                 #position = position_jitter(),
                 check_overlap = T, #nudge_x = 1,
                 ) +
    geom_sf(aes(col=winsorized), alpha=0.4, size=0.2) + 
    labs(title = "blocks with winsorized UFP predictions",
         subtitle = this_year)
  
    ggsave(file.path("output", "summary", paste0("dichotimized_winsorized_predictions", this_year, ".png")), width = 16, height = 10)

  
})

```

```{r}
ufp %>%
  mutate(state_code = substr(block_key, 1,2)) %>%
  left_join(select(fips_codes, -contains("county")) %>% distinct(), by="state_code") %>% 
  group_by(year, state_name) %>%
  summarize(
    total_blocks=n(),
    proportion_winsorized = mean(winsorized != "not changed", na.rm = T)) %>%
  arrange(-proportion_winsorized) %>%
  kable(caption = "Blocks with winsorized UFP predictions", 
        digits = 2) %>%
  kable_styling() %>% 
 scroll_box(height = "500px")


```

Note: we may want to do this same winsorized location check with the actual cohort locations


## covariates associated with winsorization

* places closer to truck routes  (m_to_truck is the inverse) are are most likely to be winsorized  

```{r}
ufp %>%
  pivot_longer(cols = c(lu_comm_p01500, lu_resi_p15000, imp_a00750, m_to_truck, ll_a1_a3_s03000)) %>%
  ggplot(aes(x=value, y=ufp_difference)) +
  facet_wrap(~year+name, scales="free") +
  geom_smooth() +
  geom_point(aes(col=winsorized), alpha=0.1, size=0.5) + 
  labs(y="UFP adjustment after winsorization",
       x= "covariate value",
       col="Prediction",
       title = "covariates associated with winsorization"
       )

ggsave(file.path("output", "summary", paste0("covariates_vs_winsorization.png")), width = 16, height = 10)


```


